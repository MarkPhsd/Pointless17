import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { AuthenticationService } from 'src/app/_services/system/authentication.service';
import { Observable, of, } from 'rxjs';
import { ClientsPOSOrders,  ISite }   from 'src/app/_interfaces';
import { SitesService } from './sites.service';
import { saveAs } from 'file-saver'
import { Papa, UnparseConfig } from 'ngx-papaparse';
// Generated by https://quicktype.io
// Generated by https://quicktype.io

export interface IReportItemSaleSummary {
  results: IReportItemSales[];
  summary: IReportItemSales;
  resultMessage: string;
  site         : ISite;
}

export interface  ReportItemSalesOptimized {
  productName:             string;
  employee:                string;
  itemTotal:               number;
  NetSales                : number;
  taxTotal1:               number;
  taxTotal2:               number;
  taxTotal3:               number;
  cRV:                     number;
  cost                   : number;
  quantity:                number;
  unitPrice:               number;
  orderCashDiscount: number;
  itemCashDiscounts: number;
  itemPercentageDiscount: number;
  pointDiscount: number;
  completionDateShort:     string;
  department: string;
  category: string
  voidAmount: number;
  voidReason: string;

}

export interface IReportItemSales {
  productName:             string;
  serialNumber:            string;
  employee:                string;
  employeeName:            string;
  posName:                 string;
  zRunID:                  string;
  balanceSheetID:          number;
  itemTotal:               number;
  taxTotal1:               number;
  taxTotal2:               number;
  taxTotal3:               number;
  cRV:                     number;
  pointDiscount:           number;
  itemCashDiscounts:       number;
  orderCashDiscount:       number;
  itemPercentageDiscount:  number;
  orderPercentageDiscount: number;
  completionDate:          string;
  orderDate:               string;
  serviceType:             string;
  prodModifierType:        number;
  giftCardType:            number;
  orderID:                 number;
  id:                      number;
  productID:               number;
  serviceFilterType:       number;
  quantity:                number;
  unitPrice:               number;
  traceProductCount:       number;
  originalPrice:           number;
  activePO:                boolean;
  clientID:                number;
  barcode:                 string;
  completionDateShort:     string;
  employeeID:              number;
  categoryID:              number;
  category:                string;
  departmentID:            number;
  department:              string;
  weightedItem:            number;
  siteID:                  number;
  cost                   : number;
  itemCost               : number;
  productCount  : number;
  voidReason    : string;
  voidAmount    : number;
  printed       : string;
  itemPrepped   : string;
  client        : ClientsPOSOrders;
  history: boolean;

}

export interface ItemPOMetrics {
   quantity: number;
   cost: number;
   net : number;
   vendorName : string;
}

export interface POSItemSearchModel {
  completionDate_From : string;
  completionDate_To : string;
  orderDate_From : string;
  orderDate_To : string;
  serviceTypes : string[]
  serviceType : string;
  serviceTypeID : number
  closedOpenAllOrders : number;
  employeeID : number
  scheduleDate_From : string;
  ccheduleDate_To : string;
  pageSize : number
  pageNumber : number
  pageCount : number
  currentPage : number
  lastPage : number
  useNameInAllFieldsForSearch : Boolean
  routeID : number
  routeDetailID : number
  greaterThanZero : number
  orderID : number
  clientID :number;
  orderBy : number
  prepStatus :number;
  printLocation :number;
  history : boolean;
  zrunID : string;
  reportRunID :number;
  showVoids: boolean;
  barcode: string;
  productName: string;
  includeMenuItem: boolean;
  productID :number;
  lessThanZero: boolean;
  ServiceTypeFilter: number;
}

export interface IReportingSearchModel {
  reportRunID: number;
  startDate:                    string;
  endDate:                      string;
  serviceTypeID:                number;
  employeeID:                   number;
  productName:                  string;
  barcode:                      string;
  prodModifierType:             string;
  userScheduledateDateForRange: boolean;
  userOrderDateForRange:        boolean;
  clientID:                     number;
  pageSize:                     number;
  pageNumber:                   number;
  groupByEmployee:              boolean;
  groupByProduct:               boolean;
  getServiceFees              : boolean;
  groupByCategory:              boolean;
  groupByDepartment:            boolean;
  groupByType                 : boolean;
  groupByDate:                  boolean;
  weightedItem:                 boolean;
  productsOnly:                 boolean;
  discountsOnly:                boolean;
  zrunID                  :     string;
  scheduleDateStart       :     string;
  scheduleDateEnd         :     string;
  pendingTransactions: boolean;
  removeGiftCards: boolean;
  itemPrepped: number;
  itemPrinted: number;
  taxFilter: number;
  groupBy: string;
}

// Generated by https://quicktype.io

export interface TaxSalesReportResults {
  results: ITaxReport[]
  summary: ITaxReport;
}
export interface ITaxReport {
  nonTaxableSalesTotal:     number;
  taxTotal1:                number;
  taxTotal2:                number;
  taxTotal3:                number;
  grossSales:               number;
  netSales:                 number;
  taxTotal                : number;
  itemTotal:                number;
  itemCost                : number;
  orderCashDiscount:        number;
  itemPercentDiscount:      number;
  itemCashDiscount:         number;
  orderPercentDiscount:     number;
  itemLoyaltyPointDiscount: number;
  crv:                      number;
  startDate:                string;
  endDate:                  string;
  giftCardIssuances:        number;
  paidOuts:                 number;
  resultsMessage          : string;
  productName             : string;
  itemType                : string;
  category                : string;
  department              : string;
  scheduleDate            : string;
  gratuity                : number;
  completed               : boolean;
  voidReason: string;
  voidAmount: number;
  taxRate1: number;
  taxRate2: number;
  taxRate3: number;
  taxLabel1: string;
  taxLabel2: string;
  taxLabel3: string;


}

export interface ITaxReportOptimized {
  nonTaxableSalesTotal:     number;
  taxTotal1:                number;
  taxTotal2:                number;
  taxTotal3:                number;
  grossSales:               number;
  netSales:                 number;
  itemTotal:                number;
  crv:                      number;
  giftCardIssuances:        number;
  paidOuts:                 number;
  productName              : string;
  itemType                : string;
  category                : string;
  department              : string;
  gratuity                : number;
  employee: string;
}


@Injectable({
  providedIn: 'root'
})
export class ReportingItemsSalesService {


  constructor( private http: HttpClient, private auth: AuthenticationService,
               private papa: Papa,
               private sitesService: SitesService) { }

  //Tax Sales Report Standard
  putSalesTaxReport(site: ISite, filter: IReportingSearchModel): Observable<ITaxReport> {

    const controller = `/ReportItemSales/`

    const endPoint = `PutSalesTaxReport`

    // const filter ={} as IReportingSearchModel
    // filter.startDate = startDate
    // filter.endDate = endDate
    // filter.zrunID  = zrunID
    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<any>(url, filter)

  };


  listAdjustedItems(site: ISite, searchModel: POSItemSearchModel): Observable<unknown> {

    const controller = `/ReportItemSales/`

    const endPoint = `ListAdjustedItems`

    const url = `${site.url}${controller}${endPoint}`
    console.log(searchModel)
    return  this.http.post<unknown>(url, searchModel )
  }

  getTopSalesByQuantity(site, startDate, endDate): Observable<IReportItemSales[]> {
    const controller = `/ReportItemSales/`

    const endPoint = `getTopSalesByQuantity`

    const parameters = `?StartDate=${startDate}&endDate=${endDate}`

    const url = `${site.url}${controller}${endPoint}${parameters}`

    return  this.http.get<IReportItemSales[]>(url )

  }

  getTopSalesByTotalPrice(site, startDate, endDate): Observable<IReportItemSales[]> {
    const controller = `/ReportItemSales/`

    const endPoint = `getTopSalesByTotalPrice`

    const parameters = `?StartDate=${startDate}&endDate=${endDate}`

    const url = `${site.url}${controller}${endPoint}${parameters}`

    return  this.http.get<IReportItemSales[]>(url )

  }

  getTopSalesByProfit(site, startDate, endDate): Observable<IReportItemSales[]> {
    const controller = `/ReportItemSales/`

    const endPoint = `getTopSalesByProfit`

    const parameters = `?StartDate=${startDate}&endDate=${endDate}`

    const url = `${site.url}${controller}${endPoint}${parameters}`

    return  this.http.get<IReportItemSales[]>(url )

  }


  getItemSalesReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getItemSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

  }

  getItemSizeSalesReport(site: ISite, model: any) : Observable<IReportItemSaleSummary> {
    model.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getItemSizeSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSaleSummary>(url, model )
  }

  getUOMReport(site: ISite, model: any) : Observable<IReportItemSaleSummary> {
    model.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `GETUOMReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.post<IReportItemSaleSummary>(url, model )
  }

  getItemQuantityGroupedReport(site: ISite, model: any): Observable<IReportItemSaleSummary> {
    model.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getItemQuantityGroupedReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSaleSummary>(url, model )
  }

  getGifCardIssueReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    IReportingSearchModel.removeGiftCards = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getItemSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

  }

  getCategorySalesReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getCategorySalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

  }

  getDepartmentSalesReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getDepartmentSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

}

  getTypeSalesReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getTypeSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

  }

  searchItemReport(site: ISite, IReportingSearchModel: IReportingSearchModel): Observable<IReportItemSales[]> {

    IReportingSearchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `searchItemReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSales[]>(url, IReportingSearchModel )

  }

  //https://localhost:44309/api/ReportItemSales/GroupItemSales
  //https://ccsposdemo.ddns.net:4444/api/ReportItemSales/GroupItemSales
  //{ "startdate": "07/01/2018", "enddate": "12/10/2020", "groupByProduct": "true" }
  groupItemSales(site: ISite, searchModel: IReportingSearchModel): Observable<IReportItemSaleSummary> {

    // console.log(searchModel)
    if (!site || !site.url) { return of(null)}

    // searchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `GroupItemSales`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<IReportItemSaleSummary>(url, searchModel)

  }

  getTransactionTypeSalesReport(site: ISite, searchModel: IReportingSearchModel): Observable<TaxSalesReportResults> {

    // console.log(searchModel)
    if (!site || !site.url) { return of(null)}

    // searchModel.productsOnly = true;

    const controller = `/ReportItemSales/`

    const endPoint = `getTransactionTypeSalesReport`

    const url = `${site.url}${controller}${endPoint}`

    return  this.http.put<TaxSalesReportResults>(url, searchModel)

  }

  downloadFile(data: any, fileName: string) {

    const replacer = (key, value) => value === null ? '' : value; // specify how you want to handle null values here
    let header
    if (data[0]) {
      header = Object.keys(data[0]);
      let csv = data.map(row => header.map(fieldName => JSON.stringify(row[fieldName], replacer)).join(','));

      if (header) {
        csv.unshift(header.join(','));
      }

      let csvArray = csv.join('\r\n');

      var blob = new Blob([csvArray], {type: 'text/csv' })
      saveAs(blob, `${fileName}.csv`);
    }
  }
    downloadFileOptions(data: any, fileName: string, removeHeader: boolean) {
      const replacer = (key, value) => value === null ? '' : value; // specify how you want to handle null values here
      let header
      if (data[0]) {
        header = Object.keys(data[0]);
        let csv = data.map(row => header.map(fieldName => JSON.stringify(row[fieldName], replacer)).join(','));

        if (removeHeader) {
          csv.unshift(header.join(','));
        }

        let csvArray = csv.join('\r\n');

        var blob = new Blob([csvArray], {type: 'text/csv' })
        saveAs(blob, `${fileName}.csv`);
      }
    }

    downloadPapa(data: any, fileName: string, options?: UnparseConfig) {

      var csv = this.papa.unparse(data,options);
      var blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
      saveAs(blob, `${fileName}.csv`);

    }


}
